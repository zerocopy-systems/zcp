import { ec as EC } from "elliptic";
import { createHash } from "crypto";

const ec = new EC("secp256k1");

/**
 * ZK Proof of policy compliance (v1.1)
 */
export interface PolicyProof {
  /** Hex-encoded STARK receipt from zkVM */
  receipt_hex: string;
  /** Image ID of the guest program */
  image_id: string;
  /** List of properties verified */
  checked_properties: string[];
  /** Timestamp of proof generation (ms) */
  timestamp_ms: number;
}

/**
 * The standard .zcp Attestation Format (v1.1)
 */
export interface ZcpAttestation {
  /** Protocol version ("1.0" or "1.1") */
  version: string;
  /** Unix timestamp (ms) of execution */
  timestamp: number;
  /** The data being attested */
  payload: unknown;
  /** Hex-encoded ECDSA signature of payload */
  signature: string;
  /** Hex-encoded Enclave Public Key */
  enclave_pubkey: string;
  /** Optional ZK proof of policy compliance (v1.1+) */
  policy_proof?: PolicyProof;
}

/**
 * Result of policy proof verification
 */
export interface PolicyVerificationResult {
  valid: boolean;
  error?: string;
  checkedProperties?: string[];
}

/**
 * Verify the attestation signature using the embedded enclave public key.
 * Note: You must verify the enclave_pubkey against AWS attestation separately.
 */
export function verifyAttestation(attestation: ZcpAttestation): boolean {
  try {
    // 1. Decode Key
    const key = ec.keyFromPublic(attestation.enclave_pubkey, "hex");

    // 2. Reconstruct Message (Payload Stringified)
    // IMPORTANT: Must match Rust/Enclave serialization EXACTLY.
    const msg = JSON.stringify(attestation.payload);
    const msgHash = createHash("sha256").update(msg).digest();

    // 3. Verify
    return key.verify(msgHash, attestation.signature);
  } catch (e) {
    console.error("Verification Error:", e);
    return false;
  }
}

/**
 * Verify the policy proof if present.
 *
 * @param attestation - The .zcp attestation to verify
 * @param expectedImageId - Optional. If provided, verifies the proof was generated by this image.
 * @param requiredProperties - List of property prefixes that must be present in the proof.
 * @returns PolicyVerificationResult with valid status and any error details
 */
export function verifyPolicyProof(
  attestation: ZcpAttestation,
  expectedImageId?: string,
  requiredProperties: string[] = [],
): PolicyVerificationResult {
  // Check if policy proof exists
  if (!attestation.policy_proof) {
    return {
      valid: false,
      error: "Policy proof missing",
    };
  }

  const proof = attestation.policy_proof;

  // Check image ID if provided
  if (expectedImageId && proof.image_id !== expectedImageId) {
    return {
      valid: false,
      error: `Image ID mismatch: expected ${expectedImageId}, got ${proof.image_id}`,
    };
  }

  // Check all required properties are present
  for (const required of requiredProperties) {
    const hasProperty = proof.checked_properties.some((p) =>
      p.startsWith(required),
    );
    if (!hasProperty) {
      return {
        valid: false,
        error: `Missing required property: ${required}`,
      };
    }
  }

  // Check receipt is not empty
  if (!proof.receipt_hex || proof.receipt_hex.length === 0) {
    return {
      valid: false,
      error: "Empty receipt",
    };
  }

  // Note: In production, we would verify the STARK receipt here
  // using a WASM build of risc0-zkvm's verification logic.

  return {
    valid: true,
    checkedProperties: proof.checked_properties,
  };
}

/**
 * Check if an attestation has a policy proof
 */
export function hasPolicyProof(attestation: ZcpAttestation): boolean {
  return (
    attestation.policy_proof !== undefined && attestation.policy_proof !== null
  );
}

/**
 * Extract the max leverage value from a policy proof, if present
 */
export function getMaxLeverage(attestation: ZcpAttestation): number | null {
  if (!attestation.policy_proof) return null;

  for (const prop of attestation.policy_proof.checked_properties) {
    if (prop.startsWith("MaxLeverage(")) {
      const match = prop.match(/MaxLeverage\((\d+)\)/);
      if (match) {
        return parseInt(match[1], 10);
      }
    }
  }
  return null;
}

/**
 * Check if a specific property was verified in the policy proof
 */
export function hasProperty(
  attestation: ZcpAttestation,
  propertyPrefix: string,
): boolean {
  if (!attestation.policy_proof) return false;
  return attestation.policy_proof.checked_properties.some((p) =>
    p.startsWith(propertyPrefix),
  );
}

/**
 * Get the version as a tuple [major, minor]
 */
export function getVersionTuple(
  attestation: ZcpAttestation,
): [number, number] | null {
  const parts = attestation.version.split(".");
  if (parts.length >= 2) {
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1], 10);
    if (!isNaN(major) && !isNaN(minor)) {
      return [major, minor];
    }
  }
  return null;
}
