"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAttestation = verifyAttestation;
exports.verifyPolicyProof = verifyPolicyProof;
exports.hasPolicyProof = hasPolicyProof;
exports.getMaxLeverage = getMaxLeverage;
exports.hasProperty = hasProperty;
exports.getVersionTuple = getVersionTuple;
const elliptic_1 = require("elliptic");
const crypto_1 = require("crypto");
const ec = new elliptic_1.ec('secp256k1');
/**
 * Verify the attestation signature using the embedded enclave public key.
 * Note: You must verify the enclave_pubkey against AWS attestation separately.
 */
function verifyAttestation(attestation) {
    try {
        // 1. Decode Key
        const key = ec.keyFromPublic(attestation.enclave_pubkey, 'hex');
        // 2. Reconstruct Message (Payload Stringified)
        // IMPORTANT: Must match Rust/Enclave serialization EXACTLY.
        const msg = JSON.stringify(attestation.payload);
        const msgHash = (0, crypto_1.createHash)('sha256').update(msg).digest();
        // 3. Verify
        return key.verify(msgHash, attestation.signature);
    }
    catch (e) {
        console.error("Verification Error:", e);
        return false;
    }
}
/**
 * Verify the policy proof if present.
 *
 * @param attestation - The .zcp attestation to verify
 * @param expectedImageId - Optional. If provided, verifies the proof was generated by this image.
 * @param requiredProperties - List of property prefixes that must be present in the proof.
 * @returns PolicyVerificationResult with valid status and any error details
 */
function verifyPolicyProof(attestation, expectedImageId, requiredProperties = []) {
    // Check if policy proof exists
    if (!attestation.policy_proof) {
        return {
            valid: false,
            error: 'Policy proof missing'
        };
    }
    const proof = attestation.policy_proof;
    // Check image ID if provided
    if (expectedImageId && proof.image_id !== expectedImageId) {
        return {
            valid: false,
            error: `Image ID mismatch: expected ${expectedImageId}, got ${proof.image_id}`
        };
    }
    // Check all required properties are present
    for (const required of requiredProperties) {
        const hasProperty = proof.checked_properties.some(p => p.startsWith(required));
        if (!hasProperty) {
            return {
                valid: false,
                error: `Missing required property: ${required}`
            };
        }
    }
    // Check receipt is not empty
    if (!proof.receipt_hex || proof.receipt_hex.length === 0) {
        return {
            valid: false,
            error: 'Empty receipt'
        };
    }
    // Note: In production, we would verify the STARK receipt here
    // using a WASM build of risc0-zkvm's verification logic.
    return {
        valid: true,
        checkedProperties: proof.checked_properties
    };
}
/**
 * Check if an attestation has a policy proof
 */
function hasPolicyProof(attestation) {
    return attestation.policy_proof !== undefined && attestation.policy_proof !== null;
}
/**
 * Extract the max leverage value from a policy proof, if present
 */
function getMaxLeverage(attestation) {
    if (!attestation.policy_proof)
        return null;
    for (const prop of attestation.policy_proof.checked_properties) {
        if (prop.startsWith('MaxLeverage(')) {
            const match = prop.match(/MaxLeverage\((\d+)\)/);
            if (match) {
                return parseInt(match[1], 10);
            }
        }
    }
    return null;
}
/**
 * Check if a specific property was verified in the policy proof
 */
function hasProperty(attestation, propertyPrefix) {
    if (!attestation.policy_proof)
        return false;
    return attestation.policy_proof.checked_properties.some(p => p.startsWith(propertyPrefix));
}
/**
 * Get the version as a tuple [major, minor]
 */
function getVersionTuple(attestation) {
    const parts = attestation.version.split('.');
    if (parts.length >= 2) {
        const major = parseInt(parts[0], 10);
        const minor = parseInt(parts[1], 10);
        if (!isNaN(major) && !isNaN(minor)) {
            return [major, minor];
        }
    }
    return null;
}
