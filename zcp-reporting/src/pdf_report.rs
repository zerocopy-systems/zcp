// ============================================================================
// PDF REPORT MODULE
// Task 4.4: PDF Report Generation
// ============================================================================

use std::fs::File;
use std::io::Write;

/// Report data structure for PDF generation
pub struct PdfReportData {
    pub provider_name: String,
    pub latency_ms: u64,
    pub daily_volume: u64,
    pub annual_loss: u64,
    pub potential_savings: u64,
    pub score: u8,
    pub grade: String,
    pub checks_passed: usize,
    pub checks_total: usize,
    pub timestamp: String,
}

/// Generate a simple Markdown report (can be converted to PDF externally)
/// Uses Markdown format that can be rendered as PDF via pandoc or similar tools
pub fn generate_markdown_report(data: &PdfReportData, output_path: &str) -> std::io::Result<()> {
    let mut file = File::create(output_path)?;

    writeln!(file, "# ZeroCopy Jitter Tax Audit Report")?;
    writeln!(file)?;
    writeln!(file, "**Generated:** {}", data.timestamp)?;
    writeln!(file, "**Report Type:** Infrastructure Latency Analysis")?;
    writeln!(file)?;
    writeln!(file, "---")?;
    writeln!(file)?;

    // Executive Summary
    writeln!(file, "## Executive Summary")?;
    writeln!(file)?;
    writeln!(file, "| Metric | Value |")?;
    writeln!(file, "|:-------|------:|")?;
    writeln!(file, "| **Overall Grade** | {} |", data.grade)?;
    writeln!(file, "| **Score** | {}/100 |", data.score)?;
    writeln!(
        file,
        "| **Checks Passed** | {}/{} |",
        data.checks_passed, data.checks_total
    )?;
    writeln!(file)?;

    // Jitter Tax Analysis
    writeln!(file, "## Jitter Tax Analysis")?;
    writeln!(file)?;
    writeln!(file, "### Current Infrastructure")?;
    writeln!(file)?;
    writeln!(file, "| Parameter | Value |")?;
    writeln!(file, "|:----------|------:|")?;
    writeln!(file, "| Signing Provider | {} |", data.provider_name)?;
    writeln!(file, "| P99 Latency | {} ms |", data.latency_ms)?;
    writeln!(
        file,
        "| Daily Trading Volume | ${} |",
        format_number(data.daily_volume)
    )?;
    writeln!(file)?;

    // Financial Impact
    writeln!(file, "### Financial Impact")?;
    writeln!(file)?;
    writeln!(file, "| Metric | Amount |")?;
    writeln!(file, "|:-------|-------:|")?;
    writeln!(
        file,
        "| **Estimated Annual Loss** | **${}** |",
        format_number(data.annual_loss)
    )?;
    writeln!(
        file,
        "| Potential Savings (ZeroCopy) | ${} |",
        format_number(data.potential_savings)
    )?;
    writeln!(file)?;

    // Comparison
    writeln!(file, "## Infrastructure Comparison")?;
    writeln!(file)?;
    writeln!(file, "| Metric | Current | ZeroCopy |")?;
    writeln!(file, "|:-------|--------:|---------:|")?;
    writeln!(
        file,
        "| Signing Provider | {} | Sentinel |",
        data.provider_name
    )?;
    writeln!(
        file,
        "| Time-to-Sign (P99) | {} ms | 42 µs |",
        data.latency_ms
    )?;
    writeln!(
        file,
        "| Annual Jitter Tax | ${} | $0 |",
        format_number(data.annual_loss)
    )?;
    writeln!(file)?;

    // Methodology
    writeln!(file, "## Methodology")?;
    writeln!(file)?;
    writeln!(file, "### Jitter Tax Formula")?;
    writeln!(file)?;
    writeln!(file, "```")?;
    writeln!(
        file,
        "Annual Loss = (Latency_ms / 1000) × Slippage_Rate × Daily_Volume × Trading_Days"
    )?;
    writeln!(file, "```")?;
    writeln!(file)?;
    writeln!(file, "### Assumptions")?;
    writeln!(file)?;
    writeln!(
        file,
        "- **Slippage Rate:** 1 bps per 100ms (Source: BIS Working Paper 955)"
    )?;
    writeln!(
        file,
        "- **Trading Days:** 365 (crypto markets operate 24/7)"
    )?;
    writeln!(
        file,
        "- **Provider Latency:** {} ms (Source: {})",
        data.latency_ms,
        get_source(&data.provider_name)
    )?;
    writeln!(file)?;

    // Call to Action
    writeln!(file, "## Next Steps")?;
    writeln!(file)?;
    writeln!(
        file,
        "1. **Book a Demo:** [zerocopy.systems/demo](https://zerocopy.systems/demo)"
    )?;
    writeln!(
        file,
        "2. **Read Documentation:** [docs.zerocopy.systems](https://docs.zerocopy.systems)"
    )?;
    writeln!(
        file,
        "3. **Try the CLI:** `zcp audit --volume YOUR_VOLUME --explain`"
    )?;
    writeln!(file)?;

    // Footer
    writeln!(file, "---")?;
    writeln!(file)?;
    writeln!(
        file,
        "*Report generated by ZCP Audit CLI v{}*",
        env!("CARGO_PKG_VERSION")
    )?;
    writeln!(
        file,
        "*ZeroCopy Systems - Sovereign Infrastructure for AI Agents*"
    )?;

    Ok(())
}

/// Format a number with commas
fn format_number(n: u64) -> String {
    let s = n.to_string();
    let mut result = String::new();
    for (i, c) in s.chars().rev().enumerate() {
        if i > 0 && i % 3 == 0 {
            result.push(',');
        }
        result.push(c);
    }
    result.chars().rev().collect()
}

/// Get source citation for provider
fn get_source(provider: &str) -> &'static str {
    match provider {
        "AWS KMS" => "AWS Re:Post Community Benchmarks (2024)",
        "Fireblocks / MPC" => "Fireblocks Performance Documentation",
        "Local HSM / Enclave" => "Industry Standard HSM Benchmarks",
        "ZeroCopy Sentinel" => "ZeroCopy Internal Benchmarks",
        _ => "User-provided measurement",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_number() {
        assert_eq!(format_number(1000), "1,000");
        assert_eq!(format_number(1000000), "1,000,000");
        assert_eq!(format_number(54750), "54,750");
    }
}
