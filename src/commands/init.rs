use anyhow::{Context, Result};
use colored::*;
use std::fs::File;
use std::io::Write;
use std::path::Path;

use zcp_reporting::ui;

pub fn run(name: Option<String>) -> Result<i32> {
    let project_name = name.unwrap_or_else(|| "my-enclave".to_string());

    ui::print_header("PROJECT SCAFFOLDING");
    ui::print_step(&format!(
        "Initializing ZeroCopy Enclave Project: {}",
        project_name
    ));

    // Safety Check: Directory exists
    if Path::new(&project_name).exists() {
        ui::print_error(
            &format!("Directory '{}' already exists", project_name),
            Some("Cannot overwrite existing project"),
            &[
                &format!("rm -rf {} # Delete existing directory", project_name),
                &format!("zcp init {}-new # Use different name", project_name),
            ],
            Some("https://zerocopy.systems/docs/cli/init"),
        );
        return Ok(1);
    }

    std::fs::create_dir(&project_name).context("Failed to create project directory")?;
    ui::print_step("Created project directory");

    // Create .gitignore
    let gitignore_content = r#"/target
/enclave.eif
/*.pem
.env
"#;
    create_file(&project_name, ".gitignore", gitignore_content)?;

    // Create enclave.toml
    let enclave_toml_content = format!(
        r#"# AWS Nitro Enclaves Configuration
# Generated by zcp init

[enclave]
name = "{}"
cpu_count = 2
memory_mib = 512
docker_uri = "{}:latest"
output_file = "{}.eif"

[network]
vsock_mode = true
"#,
        project_name, project_name, project_name
    );
    create_file(&project_name, "enclave.toml", &enclave_toml_content)?;
    ui::print_step("Created enclave.toml (Nitro Config)");

    // Create Dockerfile
    let dockerfile_content = r#"# ZeroCopy Enclave - Deterministic Build
FROM rust:1.75-slim as builder
WORKDIR /app
COPY . .
RUN cargo build --release

FROM alpine:latest
RUN apk add --no-cache dbus ca-certificates
COPY --from=builder /app/target/release/app /usr/local/bin/app
CMD ["/usr/local/bin/app"]
"#;
    create_file(&project_name, "Dockerfile", dockerfile_content)?;
    ui::print_step("Created Dockerfile");

    // Create App.toml
    let app_toml_content = format!(
        r#"# ZeroCopy Application Manifest
[package]
name = "{}"
version = "0.1.0"
authors = ["You <you@example.com>"]

[compliance]
audit_logging = true
zero_knowledge_proofs = false

[runtime]
pcr0 = ""
pcr1 = ""
pcr2 = ""
"#,
        project_name
    );
    create_file(&project_name, "App.toml", &app_toml_content)?;
    ui::print_step("Created App.toml (ZeroCopy Manifest)");

    // Create src/main.rs
    let src_dir = format!("{}/src", project_name);
    std::fs::create_dir_all(&src_dir).context("Failed to create src directory")?;

    let main_rs_content = r#"fn main() {
    println!("Hello from the Secure Enclave!");
    // Your ZeroCopy logic here
}
"#;
    create_file(&project_name, "src/main.rs", main_rs_content)?;

    // Create Cargo.toml
    let cargo_toml_content = format!(
        r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

[dependencies]
aws-nitro-enclaves-nsm-api = "0.4"
serde = {{ version = "1.0", features = ["derive"] }}
serde_json = "1.0"
"#,
        project_name
    );
    create_file(&project_name, "Cargo.toml", &cargo_toml_content)?;
    ui::print_step("Created Cargo.toml");

    println!();
    println!("{}", "PROJECT STRUCTURE:".bold());
    println!("  {}/", project_name);
    println!("  ├── enclave.toml   {}", "(Nitro Config)".dimmed());
    println!("  ├── App.toml       {}", "(ZeroCopy Manifest)".dimmed());
    println!("  ├── Dockerfile     {}", "(Build Definition)".dimmed());
    println!("  ├── Cargo.toml     {}", "(Rust Dependencies)".dimmed());
    println!("  └── src/main.rs    {}", "(Entry Point)".dimmed());

    ui::print_success(
        "PROJECT SCAFFOLDED SUCCESSFULLY",
        &[
            (&format!("cd {}", project_name), "Enter project directory"),
            ("zcp build", "Build the Enclave Image File (EIF)"),
            ("zcp deploy", "Push to AWS Auto Scaling Group"),
        ],
    );

    Ok(0)
}

fn create_file(dir: &str, filename: &str, content: &str) -> Result<()> {
    let path = format!("{}/{}", dir, filename);
    let mut file = File::create(&path).context(format!("Failed to create {}", filename))?;
    file.write_all(content.as_bytes())
        .context(format!("Failed to write to {}", filename))?;
    Ok(())
}
